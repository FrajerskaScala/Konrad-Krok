Zadanie 1. Napisz generyczną funkcję
def divide[A](list: List[A]): (List[A], List[A]) = /* ... */
która podzieli listę list na dwie części. W pierwszej będą się znajdywać elementy na parzystych indeksach w drugiej elementy na nieparzystych.
Przykład:
divide(List(1, 3, 5, 6, 7)) == (List(1, 5, 7), List(3, 6))
W rozwiązaniu skorzystaj z rekurencji ogonowej i dopasowania wzorca (nie używaj metod head i tail).



Zadanie 2. Zdefiniuj generyczną funkcję
def merge[A](a: List[A], b: List[A])(leq: (A, A) => Boolean): List[A]
która połączy ze sobą dowolne dwa ciągi elementów typu A, zgodnie z porządkiem zadanym przez funkcję leq (załóżmy, że ciągi są posortowane).
W rozwiązaniu skorzystaj z rekurencji ogonowej i dopasowania wzorca (nie używaj metod head i tail).
Przykład:
Dla: a = List(1 ,3, 5, 8), b = List(2, 4, 6, 8, 10, 12) i leq = (m, n) => m < n, funkcja powinna zwrócić List(1, 2, 3, 4, 5, 6, 8, 8, 10, 12)




Aktorzy docs:
https://nightlies.apache.org/pekko/docs/pekko/1.1/docs/actors.html#receive-messages


object MyActor {
  case class Greeting(from: String)
  case object Goodbye
}
class MyActor extends Actor with ActorLogging {
  import MyActor._
  def receive = {
    case Greeting(greeter) => log.info(s"I was greeted by $greeter.")
    case Goodbye           => log.info("Someone said goodbye to me.")
  }
}

